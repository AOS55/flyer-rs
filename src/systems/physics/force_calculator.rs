use crate::components::{Force, ForceCategory, PhysicsComponent, ReferenceFrame, SpatialComponent};
use crate::resources::PhysicsConfig;
use bevy::prelude::*;

/// A system to calculate the net forces and moments acting on entities with a `PhysicsComponent`.
/// It processes:
/// - Gravitational force.
/// - Forces and moments applied in different reference frames (Body, Inertial, Wind).
/// The results are stored in the `net_force` and `net_moment` fields of the `PhysicsComponent`.
///
/// # Arguments
/// - `query`: Query to access entities with FullAircraftState.
/// - `config`: A resource containing global physics configuration parameters, like gravity.
pub fn force_calculator_system(
    mut query: Query<(&mut PhysicsComponent, &SpatialComponent)>,
    config: Res<PhysicsConfig>,
) {
    for (mut physics, spatial) in query.iter_mut() {
        // Reset net forces before calculation
        physics.net_force = nalgebra::Vector3::zeros();
        physics.net_moment = nalgebra::Vector3::zeros();

        // --- Process Gravity First ---
        // Calculate gravity in inertial frame
        let gravity_inertial = config.gravity * physics.mass;
        // Add inertial gravity to net inertial force
        physics.net_force += gravity_inertial;
        // Gravity acts through CG, so no moment contribution to net_moment here.
        // We can still store the body-frame gravity force if needed elsewhere.
        let gravity_body_vector = spatial.attitude.inverse() * gravity_inertial;
        let gravity_force_component = Force {
            vector: gravity_body_vector,
            point: None,
            frame: ReferenceFrame::Body,
            category: ForceCategory::Gravitational,
        };
        // Clear old gravity force and add the new one (optional, depends if needed)
        physics
            .forces
            .retain(|force| force.category != ForceCategory::Gravitational);
        physics.forces.push(gravity_force_component);

        // --- Process Other Forces and Moments ---
        // Clone forces/moments lists applied by other systems (aero, thrust, etc.)
        let other_forces = physics
            .forces
            .iter()
            .filter(|f| f.category != ForceCategory::Gravitational) // Exclude gravity we just handled
            .cloned() // Clone to avoid borrow issues
            .collect::<Vec<_>>();

        let other_moments = physics
            .moments
            .iter()
            .filter(|m| m.category != ForceCategory::Gravitational) // Should be none, but good practice
            .cloned()
            .collect::<Vec<_>>();

        // Process other forces
        for force in other_forces.iter() {
            // Calculate force in inertial frame for net_force
            let force_inertial = match force.frame {
                ReferenceFrame::Body => spatial.attitude * force.vector,
                ReferenceFrame::Inertial => force.vector,
                ReferenceFrame::Wind => {
                    // TODO: Handle Wind frame transformation if needed
                    // Assuming Wind frame force needs rotation similar to Body for now
                    eprintln!("Warning: Wind frame force transformation not fully implemented in force_calculator.");
                    spatial.attitude * force.vector
                }
            };
            physics.net_force += force_inertial;

            // Calculate moment generated by this force *in the body frame*
            if let Some(point_body) = force.point {
                // Assuming point is defined in body frame
                // Get force in body frame
                let force_body = match force.frame {
                    ReferenceFrame::Body => force.vector,
                    ReferenceFrame::Inertial => spatial.attitude.inverse() * force.vector,
                    ReferenceFrame::Wind => {
                        // TODO: Handle Wind frame transformation if needed
                        eprintln!("Warning: Wind frame force transformation not fully implemented for moment calculation.");
                        spatial.attitude.inverse() * force_inertial // Example: Treat like body->inertial was done
                    }
                };
                // Calculate moment in body frame: M_body = r_body x F_body
                let moment_body_from_force = point_body.cross(&force_body);
                physics.net_moment += moment_body_from_force; // Add to body frame net moment
            }
        }

        // Process other pure moments
        for moment in other_moments.iter() {
            // Transform moment to body frame if necessary and add to net_moment
            let moment_body = match moment.frame {
                ReferenceFrame::Body => moment.vector,
                ReferenceFrame::Inertial => spatial.attitude.inverse() * moment.vector,
                ReferenceFrame::Wind => {
                    // TODO: Handle Wind frame transformation if needed
                    eprintln!("Warning: Wind frame moment transformation not fully implemented.");
                    spatial.attitude.inverse() * moment.vector // Example: Treat like inertial
                }
            };
            physics.net_moment += moment_body; // Add to body frame net moment
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use nalgebra::{UnitQuaternion, Vector3};
    use std::f64::consts::PI;

    fn setup_test_world() -> (World, PhysicsConfig) {
        let world = World::new();
        let physics_config = PhysicsConfig {
            timestep: 0.01,
            gravity: Vector3::new(0.0, 0.0, 9.81),
            max_velocity: 200.0,
            max_angular_velocity: 10.0,
        };
        (world, physics_config)
    }

    #[test]
    fn test_basic_force_calculation() {
        // Setup
        let (mut world, physics_config) = setup_test_world();
        world.insert_resource(physics_config.clone());

        let mass = 100.0; // 100kg
        let mut physics = PhysicsComponent::new(mass, nalgebra::Matrix3::identity() * 10.0);

        // Add a test force in body frame
        let test_force = Force {
            vector: Vector3::new(10.0, 0.0, 0.0), // 10N forward in body frame
            point: None,
            frame: ReferenceFrame::Body,
            category: ForceCategory::Aerodynamic,
        };
        physics.add_force(test_force);

        // Create spatial component with 45 degree pitch up
        let spatial = SpatialComponent {
            position: Vector3::zeros(),
            velocity: Vector3::zeros(),
            attitude: UnitQuaternion::from_euler_angles(0.0, PI / 4.0, 0.0),
            angular_velocity: Vector3::zeros(),
        };

        // Spawn entity
        let _entity = world.spawn((physics, spatial)).id();

        // Run system
        println!("Attitude quaternion: {:?}", spatial.attitude);

        // Before running the system, manually calculate the transformation
        let body_force = Vector3::new(10.0, 0.0, 0.0);
        let rotated_force = spatial.attitude * body_force;
        println!("Manual force transformation:");
        println!("  Body force: {:?}", body_force);
        println!("  Rotated force: {:?}", rotated_force);

        // Run system and get results
        let mut schedule = Schedule::default();
        schedule.add_systems(force_calculator_system);
        schedule.run(&mut world);

        let physics = world.query::<&PhysicsComponent>().single(&world);

        println!("\nFinal forces:");
        println!(
            "  Net force before gravity: {:?}",
            physics.net_force - physics_config.gravity * mass
        );
        println!(
            "  Gravity contribution: {:?}",
            physics_config.gravity * mass
        );
        println!("  Total net force: {:?}", physics.net_force);

        // For a 45-degree pitch up:
        let sqrt2_2 = (2.0_f64).sqrt() / 2.0; // cos(45°) = sin(45°) = 1/√2
        let force_magnitude = 10.0;

        // Forward force decomposition
        let expected_force_x = force_magnitude * sqrt2_2; // Forward component

        // Vertical force decomposition plus gravity
        let expected_force_z = -force_magnitude * sqrt2_2 + mass * physics_config.gravity.z;

        println!("Forces:");
        println!("  Expected X: {}", expected_force_x);
        println!("  Actual X: {}", physics.net_force.x);
        println!("  Expected Z: {}", expected_force_z);
        println!("  Actual Z: {}", physics.net_force.z);

        // Check forces with reasonable tolerance
        let tolerance = 1e-10;
        assert!(
            (physics.net_force.x - expected_force_x).abs() < tolerance,
            "X force mismatch: got {}, expected {}",
            physics.net_force.x,
            expected_force_x
        );
        assert!(
            (physics.net_force.z - expected_force_z).abs() < tolerance,
            "Z force mismatch: got {}, expected {}",
            physics.net_force.z,
            expected_force_z
        );
        assert!(
            physics.net_force.y.abs() < tolerance,
            "Y force should be zero, got {}",
            physics.net_force.y
        );
    }

    #[test]
    fn test_moment_calculation() {
        let (mut world, physics_config) = setup_test_world();
        world.insert_resource(physics_config.clone());

        let mass = 100.0;
        let mut physics = PhysicsComponent::new(mass, nalgebra::Matrix3::identity() * 10.0);

        // Add a force with a moment arm
        let test_force = Force {
            vector: Vector3::new(0.0, 0.0, -10.0), // 10N downward in body frame
            point: Some(Vector3::new(1.0, 0.0, 0.0)), // 1m forward of CG
            frame: ReferenceFrame::Body,
            category: ForceCategory::Aerodynamic,
        };
        physics.add_force(test_force);

        let spatial = SpatialComponent {
            position: Vector3::zeros(),
            velocity: Vector3::zeros(),
            attitude: UnitQuaternion::identity(),
            angular_velocity: Vector3::zeros(),
        };

        let _entity = world.spawn((physics, spatial)).id();

        let mut schedule = Schedule::default();
        schedule.add_systems(force_calculator_system);
        schedule.run(&mut world);

        let physics = world.query::<&PhysicsComponent>().single(&world);

        // Expected: 10N * 1m moment arm = 10Nm pitch up moment
        let expected_moment_y = 10.0;
        let tolerance = 1e-10;

        assert!(
            (physics.net_moment.y - expected_moment_y).abs() < tolerance,
            "Pitch moment mismatch: got {}, expected {}",
            physics.net_moment.y,
            expected_moment_y
        );
        assert!(
            physics.net_moment.x.abs() < tolerance,
            "Roll moment should be zero"
        );
        assert!(
            physics.net_moment.z.abs() < tolerance,
            "Yaw moment should be zero"
        );
    }

    #[test]
    fn test_gravity_transformation() {
        let physics_config = PhysicsConfig {
            timestep: 0.01,
            gravity: Vector3::new(0.0, 0.0, 9.81),
            max_velocity: 200.0,
            max_angular_velocity: 10.0,
        };

        let mass = 100.0;

        // Define the different attitudes to test
        let attitudes = vec![
            UnitQuaternion::identity(),                            // Level
            UnitQuaternion::from_euler_angles(0.0, PI / 4.0, 0.0), // 45° pitch up
            UnitQuaternion::from_euler_angles(PI, 0.0, 0.0),       // Inverted
        ];

        for attitude in attitudes {
            // Create a new World instance for each test case
            let mut world = World::new();
            world.insert_resource(physics_config.clone());

            let mut physics = PhysicsComponent::new(mass, nalgebra::Matrix3::identity() * 10.0);

            let spatial = SpatialComponent {
                position: Vector3::zeros(),
                velocity: Vector3::zeros(),
                attitude,
                angular_velocity: Vector3::zeros(),
            };

            let entity = world.spawn((physics.clone(), spatial)).id();

            // Run the force calculation system
            let mut schedule = Schedule::default();
            schedule.add_systems(force_calculator_system);
            schedule.run(&mut world);

            // Retrieve the updated PhysicsComponent
            let physics_result = world
                .get::<PhysicsComponent>(entity)
                .expect("Entity should have a PhysicsComponent");

            // Expected gravitational force
            let expected_gravity = physics_config.gravity * mass;

            println!("Attitude: {:?}", attitude.euler_angles());
            println!("Net force: {:?}", physics_result.net_force);
            println!("Expected gravity: {:?}", expected_gravity);

            // Validate the results
            let magnitude_difference =
                (physics_result.net_force.norm() - expected_gravity.norm()).abs();
            assert!(
                magnitude_difference < 1e-8,
                "Gravity magnitude mismatch: got {}, expected {}",
                physics_result.net_force.norm(),
                expected_gravity.norm()
            );
        }
    }

    #[test]
    fn test_extreme_attitude_force_transformation() {
        let physics_config = PhysicsConfig {
            timestep: 0.01,
            gravity: Vector3::new(0.0, 0.0, 9.81),
            max_velocity: 200.0,
            max_angular_velocity: 10.0,
        };

        let mass = 100.0;

        // Define test cases with extreme attitudes
        let test_cases = vec![
            (
                "85_deg_pitch",
                UnitQuaternion::from_euler_angles(0.0, 85.0 * PI / 180.0, 0.0),
            ),
            (
                "95_deg_pitch",
                UnitQuaternion::from_euler_angles(0.0, 95.0 * PI / 180.0, 0.0),
            ),
            (
                "180_deg_roll",
                UnitQuaternion::from_euler_angles(PI, 0.0, 0.0),
            ),
            (
                "45_roll_45_pitch",
                UnitQuaternion::from_euler_angles(PI / 4.0, PI / 4.0, 0.0),
            ),
        ];

        for (name, attitude) in test_cases {
            // Create a new World instance for each test case
            let mut world = World::new();
            world.insert_resource(physics_config.clone());

            let mut physics = PhysicsComponent::new(mass, nalgebra::Matrix3::identity() * 10.0);

            // Add a test force in the body frame
            let test_force = Force {
                vector: Vector3::new(10.0, 0.0, 0.0),
                point: None,
                frame: ReferenceFrame::Body,
                category: ForceCategory::Aerodynamic,
            };
            physics.add_force(test_force.clone());

            let spatial = SpatialComponent {
                position: Vector3::zeros(),
                velocity: Vector3::zeros(),
                attitude,
                angular_velocity: Vector3::zeros(),
            };

            let entity = world.spawn((physics.clone(), spatial)).id();

            // Run the force calculation system
            let mut schedule = Schedule::default();
            schedule.add_systems(force_calculator_system);
            schedule.run(&mut world);

            // Retrieve the updated PhysicsComponent
            let physics_result = world
                .get::<PhysicsComponent>(entity)
                .expect("Entity should have a PhysicsComponent");

            // Expected inertial force transformation
            let expected_inertial_force = spatial.attitude * test_force.vector;
            let expected_gravity_body =
                spatial.attitude.inverse() * (physics_config.gravity * mass);
            let expected_gravity_inertial = physics_config.gravity * mass;

            println!("\nTest case: {}", name);
            println!("Attitude quaternion: {:?}", attitude);
            println!("Euler angles: {:?} radians", attitude.euler_angles());
            println!(
                "Expected body->inertial force: {:?}",
                expected_inertial_force
            );
            println!(
                "Actual force without gravity: {:?}",
                physics_result.net_force - expected_gravity_inertial
            );
            println!(
                "Expected gravity in body frame: {:?}",
                expected_gravity_body
            );

            // Validate the force transformation
            let tolerance = 1e-8;
            assert!(
                (physics_result.net_force - expected_gravity_inertial - expected_inertial_force)
                    .norm()
                    < tolerance,
                "Force transformation error in {}: expected {:?}, got {:?}",
                name,
                expected_inertial_force,
                physics_result.net_force - expected_gravity_inertial
            );
        }
    }
}
