use crate::components::{
    Force, ForceCategory, Moment, PhysicsComponent, ReferenceFrame, SpatialComponent,
};
use crate::resources::PhysicsConfig;
use bevy::prelude::*;
use nalgebra::{UnitQuaternion, Vector3}; // Added Matrix3, UnitQuaternion just in case

// --- Pure Calculation Logic ---

/// Calculates net inertial forces and net body moments from lists of applied forces/moments.
/// Also calculates the body-frame representation of gravity.
/// Pure function: Takes data slices/references, returns calculated vector values.
///
/// # Arguments
/// * `input_forces` - Slice of forces applied by other systems (aero, propulsion, etc.). Should ideally not contain gravity from previous steps.
/// * `input_moments` - Slice of moments applied by other systems.
/// * `attitude` - Current aircraft attitude (inertial to body rotation).
/// * `mass` - Aircraft mass.
/// * `gravity_inertial` - Gravity vector in the inertial frame (e.g., [0, 0, 9.81]).
///
/// # Returns
/// Tuple: `(net_force_inertial, net_moment_body, gravity_body_vector)`
/// - `net_force_inertial`: The sum of all forces transformed into the inertial frame.
/// - `net_moment_body`: The sum of all moments transformed into the body frame (including moments generated by forces applied away from the CG).
/// - `gravity_body_vector`: The gravity force vector expressed in the body frame.
pub fn calculate_net_forces_moments(
    input_forces: &[Force],
    input_moments: &[Moment],
    attitude: &UnitQuaternion<f64>,
    mass: f64,
    gravity_inertial: &Vector3<f64>,
) -> (Vector3<f64>, Vector3<f64>, Vector3<f64>) {
    let mut net_force_inertial = Vector3::zeros();
    let mut net_moment_body = Vector3::zeros();

    // --- Process Gravity ---
    // Calculate gravity force in the inertial frame
    let gravity_inertial_force = gravity_inertial * mass;
    // Add gravity's contribution to the net inertial force
    net_force_inertial += gravity_inertial_force;
    // Calculate the gravity force vector as expressed in the body frame
    let gravity_body_vector = attitude.inverse() * gravity_inertial_force;
    // Note: Gravity acting at the CG (assumed origin of body frame) produces no moment *about the CG*.

    // --- Process Other Forces (Aero, Propulsion, etc.) ---
    for force in input_forces.iter() {
        // Skip any lingering gravity components in the list, as we calculate it fresh
        if force.category == ForceCategory::Gravitational {
            continue;
        }

        // --- Contribution to Net Inertial Force ---
        // Transform the force vector into the inertial frame for summation
        let force_inertial = match force.frame {
            ReferenceFrame::Body => attitude * force.vector,
            ReferenceFrame::Inertial => force.vector,
            ReferenceFrame::Wind => {
                // TODO: Implement proper Wind frame to Inertial transformation if needed
                // This requires knowledge of the wind vector and potentially airspeed.
                // Placeholder: Treat like Body frame - this is likely incorrect for Wind frame.
                eprintln!("Warning: Wind->Inertial force transformation not implemented.");
                attitude * force.vector
            }
        };
        net_force_inertial += force_inertial;

        // --- Contribution to Net Body Moment (if force applied away from CG) ---
        if let Some(point_body) = force.point {
            // 'point_body' is the application point vector from CG in body frame
            // To calculate moment M = r x F, F must be in the body frame
            let force_body = match force.frame {
                ReferenceFrame::Body => force.vector,
                ReferenceFrame::Inertial => attitude.inverse() * force.vector,
                ReferenceFrame::Wind => {
                    // TODO: Implement proper Wind frame to Body transformation if needed
                    eprintln!(
                        "Warning: Wind->Body force transformation not implemented for moment calc."
                    );
                    // Placeholder: Transform from inertial frame (calculated above) to body frame
                    attitude.inverse() * force_inertial
                }
            };
            // Calculate the moment generated by this force in the body frame
            let moment_from_force_body = point_body.cross(&force_body);
            net_moment_body += moment_from_force_body;
        }
    }

    // --- Process Other Moments (Aero, Propulsion, etc.) ---
    for moment in input_moments.iter() {
        // Skip any lingering gravity moments (shouldn't exist)
        if moment.category == ForceCategory::Gravitational {
            continue;
        }
        // Transform the moment vector into the body frame for summation
        let moment_body = match moment.frame {
            ReferenceFrame::Body => moment.vector,
            ReferenceFrame::Inertial => attitude.inverse() * moment.vector,
            ReferenceFrame::Wind => {
                // TODO: Implement proper Wind frame to Body moment transformation if needed
                eprintln!("Warning: Wind->Body moment transformation not implemented.");
                // Placeholder: Treat like Inertial frame
                attitude.inverse() * moment.vector
            }
        };
        net_moment_body += moment_body;
    }

    // Return the calculated net values and the body-frame gravity vector
    (net_force_inertial, net_moment_body, gravity_body_vector)
}

// --- Bevy System (Wrapper) ---

/// Bevy system that calculates net forces and moments for entities with PhysicsComponent.
/// It calls the pure `calculate_net_forces_moments` function and updates the component state.
/// Should run after systems that add forces/moments (like aero, propulsion) and before the integrator.
pub fn force_calculator_system(
    mut query: Query<(&mut PhysicsComponent, &SpatialComponent)>,
    config: Res<PhysicsConfig>, // Access global physics config (for gravity)
) {
    for (mut physics, spatial) in query.iter_mut() {
        // 1. Prepare inputs for the pure function
        // Clone the force/moment lists added by other systems in this frame.
        // It's important that aero_force_system, propulsion_system, etc., run *before* this system.
        let input_forces = physics.forces.clone();
        let input_moments = physics.moments.clone();

        // 2. Call the pure calculation function
        let (
            net_force_inertial,  // Result 1: Net force (inertial frame)
            net_moment_body,     // Result 2: Net moment (body frame)
            gravity_body_vector, // Result 3: Gravity vector (body frame)
        ) = calculate_net_forces_moments(
            // Call the pure function
            &input_forces,     // Pass slice of cloned forces
            &input_moments,    // Pass slice of cloned moments
            &spatial.attitude, // Pass current attitude from SpatialComponent
            physics.mass,      // Pass mass from PhysicsComponent
            &config.gravity,   // Pass inertial gravity vector from PhysicsConfig resource
        );

        // 3. Update the PhysicsComponent fields with the calculated results
        physics.net_force = net_force_inertial;
        physics.net_moment = net_moment_body;

        // 4. Update the stored gravity force component (matches original system's behavior)
        // Create the new gravity force component struct using the calculated vector
        let new_gravity_force_component = Force {
            vector: gravity_body_vector,
            point: None,                 // Gravity acts at CG
            frame: ReferenceFrame::Body, // We calculated the body frame version
            category: ForceCategory::Gravitational,
        };
        // Efficiently update the list: remove old gravity, add new one.
        physics
            .forces
            .retain(|force| force.category != ForceCategory::Gravitational);
        physics.forces.push(new_gravity_force_component);

        // Optional: Clear any potential (erroneous) gravity moments
        physics
            .moments
            .retain(|moment| moment.category != ForceCategory::Gravitational);

        // Resetting net forces *within* the PhysicsComponent was done in the pure function implicitly
        // by starting summations from zero. The component fields are overwritten here.
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use nalgebra::{UnitQuaternion, Vector3};
    use std::f64::consts::PI;

    fn setup_test_world() -> (World, PhysicsConfig) {
        let world = World::new();
        let physics_config = PhysicsConfig {
            timestep: 0.01,
            gravity: Vector3::new(0.0, 0.0, 9.81),
            max_velocity: 200.0,
            max_angular_velocity: 10.0,
        };
        (world, physics_config)
    }

    #[test]
    fn test_basic_force_calculation() {
        // Setup
        let (mut world, physics_config) = setup_test_world();
        world.insert_resource(physics_config.clone());

        let mass = 100.0; // 100kg
        let mut physics = PhysicsComponent::new(mass, nalgebra::Matrix3::identity() * 10.0);

        // Add a test force in body frame
        let test_force = Force {
            vector: Vector3::new(10.0, 0.0, 0.0), // 10N forward in body frame
            point: None,
            frame: ReferenceFrame::Body,
            category: ForceCategory::Aerodynamic,
        };
        physics.add_force(test_force);

        // Create spatial component with 45 degree pitch up
        let spatial = SpatialComponent {
            position: Vector3::zeros(),
            velocity: Vector3::zeros(),
            attitude: UnitQuaternion::from_euler_angles(0.0, PI / 4.0, 0.0),
            angular_velocity: Vector3::zeros(),
        };

        // Spawn entity
        let _entity = world.spawn((physics, spatial)).id();

        // Run system
        println!("Attitude quaternion: {:?}", spatial.attitude);

        // Before running the system, manually calculate the transformation
        let body_force = Vector3::new(10.0, 0.0, 0.0);
        let rotated_force = spatial.attitude * body_force;
        println!("Manual force transformation:");
        println!("  Body force: {:?}", body_force);
        println!("  Rotated force: {:?}", rotated_force);

        // Run system and get results
        let mut schedule = Schedule::default();
        schedule.add_systems(force_calculator_system);
        schedule.run(&mut world);

        let physics = world.query::<&PhysicsComponent>().single(&world);

        println!("\nFinal forces:");
        println!(
            "  Net force before gravity: {:?}",
            physics.net_force - physics_config.gravity * mass
        );
        println!(
            "  Gravity contribution: {:?}",
            physics_config.gravity * mass
        );
        println!("  Total net force: {:?}", physics.net_force);

        // For a 45-degree pitch up:
        let sqrt2_2 = (2.0_f64).sqrt() / 2.0; // cos(45°) = sin(45°) = 1/√2
        let force_magnitude = 10.0;

        // Forward force decomposition
        let expected_force_x = force_magnitude * sqrt2_2; // Forward component

        // Vertical force decomposition plus gravity
        let expected_force_z = -force_magnitude * sqrt2_2 + mass * physics_config.gravity.z;

        println!("Forces:");
        println!("  Expected X: {}", expected_force_x);
        println!("  Actual X: {}", physics.net_force.x);
        println!("  Expected Z: {}", expected_force_z);
        println!("  Actual Z: {}", physics.net_force.z);

        // Check forces with reasonable tolerance
        let tolerance = 1e-10;
        assert!(
            (physics.net_force.x - expected_force_x).abs() < tolerance,
            "X force mismatch: got {}, expected {}",
            physics.net_force.x,
            expected_force_x
        );
        assert!(
            (physics.net_force.z - expected_force_z).abs() < tolerance,
            "Z force mismatch: got {}, expected {}",
            physics.net_force.z,
            expected_force_z
        );
        assert!(
            physics.net_force.y.abs() < tolerance,
            "Y force should be zero, got {}",
            physics.net_force.y
        );
    }

    #[test]
    fn test_moment_calculation() {
        let (mut world, physics_config) = setup_test_world();
        world.insert_resource(physics_config.clone());

        let mass = 100.0;
        let mut physics = PhysicsComponent::new(mass, nalgebra::Matrix3::identity() * 10.0);

        // Add a force with a moment arm
        let test_force = Force {
            vector: Vector3::new(0.0, 0.0, -10.0), // 10N downward in body frame
            point: Some(Vector3::new(1.0, 0.0, 0.0)), // 1m forward of CG
            frame: ReferenceFrame::Body,
            category: ForceCategory::Aerodynamic,
        };
        physics.add_force(test_force);

        let spatial = SpatialComponent {
            position: Vector3::zeros(),
            velocity: Vector3::zeros(),
            attitude: UnitQuaternion::identity(),
            angular_velocity: Vector3::zeros(),
        };

        let _entity = world.spawn((physics, spatial)).id();

        let mut schedule = Schedule::default();
        schedule.add_systems(force_calculator_system);
        schedule.run(&mut world);

        let physics = world.query::<&PhysicsComponent>().single(&world);

        // Expected: 10N * 1m moment arm = 10Nm pitch up moment
        let expected_moment_y = 10.0;
        let tolerance = 1e-10;

        assert!(
            (physics.net_moment.y - expected_moment_y).abs() < tolerance,
            "Pitch moment mismatch: got {}, expected {}",
            physics.net_moment.y,
            expected_moment_y
        );
        assert!(
            physics.net_moment.x.abs() < tolerance,
            "Roll moment should be zero"
        );
        assert!(
            physics.net_moment.z.abs() < tolerance,
            "Yaw moment should be zero"
        );
    }

    #[test]
    fn test_gravity_transformation() {
        let physics_config = PhysicsConfig {
            timestep: 0.01,
            gravity: Vector3::new(0.0, 0.0, 9.81),
            max_velocity: 200.0,
            max_angular_velocity: 10.0,
        };

        let mass = 100.0;

        // Define the different attitudes to test
        let attitudes = vec![
            UnitQuaternion::identity(),                            // Level
            UnitQuaternion::from_euler_angles(0.0, PI / 4.0, 0.0), // 45° pitch up
            UnitQuaternion::from_euler_angles(PI, 0.0, 0.0),       // Inverted
        ];

        for attitude in attitudes {
            // Create a new World instance for each test case
            let mut world = World::new();
            world.insert_resource(physics_config.clone());

            let physics = PhysicsComponent::new(mass, nalgebra::Matrix3::identity() * 10.0);

            let spatial = SpatialComponent {
                position: Vector3::zeros(),
                velocity: Vector3::zeros(),
                attitude,
                angular_velocity: Vector3::zeros(),
            };

            let entity = world.spawn((physics.clone(), spatial)).id();

            // Run the force calculation system
            let mut schedule = Schedule::default();
            schedule.add_systems(force_calculator_system);
            schedule.run(&mut world);

            // Retrieve the updated PhysicsComponent
            let physics_result = world
                .get::<PhysicsComponent>(entity)
                .expect("Entity should have a PhysicsComponent");

            // Expected gravitational force
            let expected_gravity = physics_config.gravity * mass;

            println!("Attitude: {:?}", attitude.euler_angles());
            println!("Net force: {:?}", physics_result.net_force);
            println!("Expected gravity: {:?}", expected_gravity);

            // Validate the results
            let magnitude_difference =
                (physics_result.net_force.norm() - expected_gravity.norm()).abs();
            assert!(
                magnitude_difference < 1e-8,
                "Gravity magnitude mismatch: got {}, expected {}",
                physics_result.net_force.norm(),
                expected_gravity.norm()
            );
        }
    }

    #[test]
    fn test_extreme_attitude_force_transformation() {
        let physics_config = PhysicsConfig {
            timestep: 0.01,
            gravity: Vector3::new(0.0, 0.0, 9.81),
            max_velocity: 200.0,
            max_angular_velocity: 10.0,
        };

        let mass = 100.0;

        // Define test cases with extreme attitudes
        let test_cases = vec![
            (
                "85_deg_pitch",
                UnitQuaternion::from_euler_angles(0.0, 85.0 * PI / 180.0, 0.0),
            ),
            (
                "95_deg_pitch",
                UnitQuaternion::from_euler_angles(0.0, 95.0 * PI / 180.0, 0.0),
            ),
            (
                "180_deg_roll",
                UnitQuaternion::from_euler_angles(PI, 0.0, 0.0),
            ),
            (
                "45_roll_45_pitch",
                UnitQuaternion::from_euler_angles(PI / 4.0, PI / 4.0, 0.0),
            ),
        ];

        for (name, attitude) in test_cases {
            // Create a new World instance for each test case
            let mut world = World::new();
            world.insert_resource(physics_config.clone());

            let mut physics = PhysicsComponent::new(mass, nalgebra::Matrix3::identity() * 10.0);

            // Add a test force in the body frame
            let test_force = Force {
                vector: Vector3::new(10.0, 0.0, 0.0),
                point: None,
                frame: ReferenceFrame::Body,
                category: ForceCategory::Aerodynamic,
            };
            physics.add_force(test_force.clone());

            let spatial = SpatialComponent {
                position: Vector3::zeros(),
                velocity: Vector3::zeros(),
                attitude,
                angular_velocity: Vector3::zeros(),
            };

            let entity = world.spawn((physics.clone(), spatial)).id();

            // Run the force calculation system
            let mut schedule = Schedule::default();
            schedule.add_systems(force_calculator_system);
            schedule.run(&mut world);

            // Retrieve the updated PhysicsComponent
            let physics_result = world
                .get::<PhysicsComponent>(entity)
                .expect("Entity should have a PhysicsComponent");

            // Expected inertial force transformation
            let expected_inertial_force = spatial.attitude * test_force.vector;
            let expected_gravity_body =
                spatial.attitude.inverse() * (physics_config.gravity * mass);
            let expected_gravity_inertial = physics_config.gravity * mass;

            println!("\nTest case: {}", name);
            println!("Attitude quaternion: {:?}", attitude);
            println!("Euler angles: {:?} radians", attitude.euler_angles());
            println!(
                "Expected body->inertial force: {:?}",
                expected_inertial_force
            );
            println!(
                "Actual force without gravity: {:?}",
                physics_result.net_force - expected_gravity_inertial
            );
            println!(
                "Expected gravity in body frame: {:?}",
                expected_gravity_body
            );

            // Validate the force transformation
            let tolerance = 1e-8;
            assert!(
                (physics_result.net_force - expected_gravity_inertial - expected_inertial_force)
                    .norm()
                    < tolerance,
                "Force transformation error in {}: expected {:?}, got {:?}",
                name,
                expected_inertial_force,
                physics_result.net_force - expected_gravity_inertial
            );
        }
    }
}
